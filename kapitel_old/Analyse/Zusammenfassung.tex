\subsection{Zusammenfassung}
\label{subsec:zusammenfassung}
Das primäre Ziel dieser Analyse war es, die Performance von den zwei \ac{gui}-Frameworks
zu testen. Die Ergebnisse dieser Analyse zeigten, dass Qt Blazor in fast allen
vorgestellten Szenarien überlegen war. Lediglich beim Szenario #9 \emph{Den Text einer Textbox
verändern} zeigte sich, dass die Blazor Server-Architektur leicht überlegen war.
\newline
\newline
Ein möglicher Grund für die Überlegenheit von Qt könnte sein, dass Qt eine
native Desktopanwendung ist. Die Überlegenheit von Qt könnte sich auch dadurch erklären, da C++
eine sehr hardwarenahe Programmiersprache ist.
\newline
\newline
Interessant war jedoch auch das Verhalten der beiden Blazor-Architekturen zu beobachten. Werden
die ersten sechs vorgestellten Szenarien betrachtet zeigt
sich, dass die WebAssembly-Architektur wesentlich schneller als die Server-Architektur scheint.
Dies könnte daran liegen, dass die Server-Architektur, die generierten Elemente
erst zum Client senden muss.
\newline
\newline
Anders scheint es bei den Szenarien sieben bis neun, bei denen etwas gelesen oder geschrieben
wurde. Dort zeigt sich die Server-Architektur als wesentlich performanter. Hier könnte die
Überlegenheit daran liegen, da die Server-Architektur, die Daten schon lokal zur Verfügung stehen.
Somit können die Daten direkt verarbeitet werden.
\newline
\newline
Werden die Ergebnisse der Tabellenstruktur und der Baumstruktur gegenübergestellt, so könnte
behauptet werden, dass die Server-Architektur performanter scheint, wenn mit kleineren
Datenmengen gearbeitet wird. Die WebAssembly-Architektur hingegen, zeigte sich mit größeren
Datenmengen performanter.